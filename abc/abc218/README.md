# 問題
https://atcoder.jp/contests/abc218

## 結果
A, B, Dは自力

C, Eは理解した．

## A, B
特になし

## C
難しそう

とりあえずパス

pythonで二次元配列の回転は以下の式で実現できる．
```python
# Sを二次元配列とする
rotS = list(zip(*S[::-1]))
```

中身を考えるとわかりやすい．

```python
original = [[1, 2],
            [3, 4]]

>>> original[::-1]   # elements of original are reversed
[[3, 4], [1, 2]]

# *をつけてアンパックすると以下と同等
Zip([3, 4],
    [1, 2])

>>> list(Zip([3, 4],
             [1, 2]))
[[3, 1], [4, 2]]
```

よって90度回転できている．


回転ができたら，平行移動で一致するか確認すれば良い．

平行移動の際に物体は境界線を跨いで移動しないので，物体の左上を見つけてそれが一致するように片方の物体を動かし，全体が一致しているかどうかを判定すれば良い．

境界線を跨ぐものだと勘違いして難しく考えてしまっていた．

## D
とりあえず2点の組み合わせて，
その組み合わせの座標から四角形を作れる位置に点が存在するかを判断すればいけそう．

この方針でAC

## E
### 案
~~切断辺という，この辺を切断したらグラフが二分されるような辺を見つけていって，
コスト的に大丈夫だったら切断すればいけそう．~~

~~橋ともいうらしい．~~

この方法だと絶対に切ってはいけないところは見つかるが，切っていった後もそれらの辺だけ切らなければ連結であるわけではない．

### 解説
この問題は最小全域木問題という．

最小全域木とは閉路を持たないように全てのノードを結んだ木のこと．

最小全域木問題はクラスカル法で解ける．

クラスカル法はUnionFindを用いて以下の手順で簡単に解くことができる．


1. 辺をコストが低い順にソートしておく．
2. コストが低い順に辺を取り出して，辺を構成している二つのノードをくっつけるかどうか判断する．

    ここで判断の基準は二つのノードが既に繋がっているかどうか．
    
    既に繋がっているような場合(根が同じ場合)にはもう一度くっつけてしまうと閉路ができてしまうのでくっつけない．

    繋がっていない場合にはくっつける．

以上の操作だけで最小全域木を作成することが可能．

ただし，今回の問題では報酬が大きくなるように辺を削除していき，コストがマイナスの辺の場合には逆にコストを払わなければいけないので，コストが負の辺は閉路を作ってしまうような場合でもつなげてしまって良い．
